package amf.tools

import java.io.{File, FileWriter}

import amf.core.metamodel.Type.Scalar
import amf.core.metamodel.domain.DomainElementModel
import amf.core.metamodel.{Field, Obj, Type}
import amf.core.vocabulary.Namespace
import amf.plugins.domain.webapi.metamodel.WebApiModel
import org.reflections.Reflections
import org.reflections.scanners.SubTypesScanner

import scala.collection.mutable

// Case classes to accumulate results
case class DialectNodeMapping(name: String,
                              classTerm: String,
                              propertyMappings: List[DialectPropertyMapping],
                              isShape: Boolean)
case class DialectPropertyMapping(name: String, propertyTerm: String, range: String, allowMultiple: Boolean)

/**
  * Logic that generates a 'canonical' dialect matching the structure in the meta-model for WebAPIs.
  * The goal of this dialect is to match the JSON-LD graph generated after parsing a RAML/OAS file with AMF.
  * This is different from the 'lexical' dialect for editing graph used by LS and generated by the DialectExporter object.
  */
object CanonicalWebAPIDialectExporter {

  val DIALECT_FILE = "canonical_webapi.yaml"
  val WELL_KNOWN_VOCABULARIES = Map[String, String](
    "http://a.ml/vocabularies/document#"    -> "../vocabularies/aml_doc.yaml",
    "http://a.ml/vocabularies/data#"        -> "../vocabularies/data_model.yaml",
    "http://a.ml/vocabularies/apiContract#" -> "../vocabularies/api_contract.yaml",
    "http://a.ml/vocabularies/apiBinding#"  -> "../vocabularies/api_binding.yaml",
    "http://a.ml/vocabularies/core#"        -> "../vocabularies/core.yaml",
    "http://a.ml/vocabularies/meta#"        -> "../vocabularies/aml_meta.yaml",
    "http://a.ml/vocabularies/security#"    -> "../vocabularies/security.yaml",
    "http://a.ml/vocabularies/shapes#"      -> "../vocabularies/data_shapes.yaml"
  )

  val reflectionsWebApi    = new Reflections("amf.plugins.domain.webapi.metamodel", new SubTypesScanner(false))
  val reflectionsShapes    = new Reflections("amf.plugins.domain.shapes.metamodel", new SubTypesScanner(false))
  val reflectionsCore      = new Reflections("amf.core.metamodel.domain.extensions", new SubTypesScanner(false))
  val reflectionsTemplates = new Reflections("amf.core.metamodel.domain.templates", new SubTypesScanner(false))
  val reflectionsDataNode  = new Reflections("amf.core.metamodel.domain", new SubTypesScanner(false))

  var nodeMappings: Map[String, DialectNodeMapping] = Map()

  def toCamelCase(str: String): String = {
    // str.replace(" ", "")
    val words = str.split("\\s+")
    if (words.size == 1) {
      words.head
    } else {
      (Seq(words.head) ++ words.tail.map(_.capitalize)).mkString
    }
  }

  def metaTypeToDialectRange(metaType: Type): (String, Boolean) = {
    metaType match {
      // objects
      case metaModel: Obj => (toCamelCase(metaModel.doc.displayName), false)
      // scalars
      case scalar: Scalar if scalar == Type.Str        => ("string", false)
      case scalar: Scalar if scalar == Type.RegExp     => ("string", false)
      case scalar: Scalar if scalar == Type.Int        => ("integer", false)
      case scalar: Scalar if scalar == Type.Float      => ("float", false)
      case scalar: Scalar if scalar == Type.Double     => ("double", false)
      case scalar: Scalar if scalar == Type.Time       => ("time", false)
      case scalar: Scalar if scalar == Type.Date       => ("date", false)
      case scalar: Scalar if scalar == Type.DateTime   => ("dateTime", false)
      case scalar: Scalar if scalar == Type.Iri        => ("uri", false)
      case scalar: Scalar if scalar == Type.EncodedIri => ("uri", false)
      case scalar: Scalar if scalar == Type.Bool       => ("boolean", false)
      // collections
      case Type.Array(t)       => (metaTypeToDialectRange(t)._1, true)
      case Type.SortedArray(t) => (metaTypeToDialectRange(t)._1, true)
    }
  }

  def buildPropertyMapping(field: Field): DialectPropertyMapping = {
    val propertyTerm           = field.value.iri()
    val name                   = toCamelCase(field.doc.displayName).replace("\\.", "")
    val (range, allowMultiple) = metaTypeToDialectRange(field.`type`)

    DialectPropertyMapping(name, propertyTerm, range, allowMultiple)
  }

  def buildNodeMapping(klassName: String, modelObject: Obj): DialectNodeMapping = {
    val doc         = modelObject.doc
    val types       = modelObject.`type`.map(_.iri())
    val id          = types.head
    val displayName = doc.displayName
    val description = doc.description
    val vocab       = doc.vocabulary.filename

    // index fields
    val propertyTerms = modelObject.fields.map(buildPropertyMapping)

    val isShape = types.contains((Namespace.Shacl + "Shape").iri())
    val nodeMapping = DialectNodeMapping(name = toCamelCase(displayName),
                                         classTerm = id,
                                         propertyMappings = propertyTerms,
                                         isShape = isShape)

    nodeMapping
  }

  def parseMetaObject(klassName: String): Option[DialectNodeMapping] = {
    nodeMappings.get(klassName) match {
      case cached @ Some(_) => cached
      case _ =>
        try {
          val singleton = Class.forName(klassName)
          singleton.getField("MODULE$").get(singleton) match {
            case modelObject: Obj =>
              val nodeMapping = buildNodeMapping(klassName, modelObject)
              nodeMappings += (klassName -> nodeMapping)
              println(klassName)
              Some(nodeMapping)
            case other =>
              //println(s"Other thing: $other")
              None
          }
        } catch {
          case _: ClassNotFoundException =>
            //println(s"NOT FOUND '${singletonKlassName}'")
            None
          case _: NoSuchFieldException =>
            //println(s"NOT FIELD '${singletonKlassName}'")
            None
        }
    }
  }

  def allowedShapePropertyMapping(propertyTerm: String, isBaseShape: Boolean): Boolean = {
    if (isBaseShape) {
      val shapeMapping = nodeMappings("amf.core.metamodel.domain.ShapeModel$")
      val duplicatedPropertyFound = shapeMapping.propertyMappings.find { p =>
        p.propertyTerm == propertyTerm
      }
      duplicatedPropertyFound.isEmpty
    } else {
      true
    }
  }

  def allowedAnyShapePropertyMapping(propertyTerm: String, isAnyShape: Boolean): Boolean = {
    if (isAnyShape) {
      val shapeMapping = nodeMappings("amf.plugins.domain.shapes.metamodel.AnyShapeModel$")
      val duplicatedPropertyFound = shapeMapping.propertyMappings.find { p =>
        p.propertyTerm == propertyTerm
      }
      duplicatedPropertyFound.isEmpty
    } else {
      true
    }
  }

  val blacklistedProperties: Set[String] = Set(
    (Namespace.Document + "extends").iri(),
    (Namespace.Document + "link-target").iri(),
    (Namespace.Document + "link-label").iri(),
    (Namespace.Document + "recursive").iri()
  )

  val blacklistedRanges: Set[String] = Set(
    "DataNode"
  )

  // Base classes that should not appear in the dialect
  val blacklistedMappings: Set[String] = Set(
    "Settings",
    "ParametrizedDeclaration",
    "LinkableElement",
    "DomainElement"
  )

  val shapeUnionDeclaration = "DataShapesUnion"

  val shapeTypeDiscriminator =
    """    typeDiscriminatorName: type
      |    typeDiscriminator:
      |      Union: UnionShape
      |      Tuple: TupleShape
      |      Node: NodeShape
      |      Array: ArrayShape
      |      Schema: SchemaShape
      |      File: FileShape
      |      Nil: NilShape
      |      Scalar: ScalarShape
      |      Any: AnyShape
      |      Recursive: RecursiveShape
    """.stripMargin

  val shapeUnionRange =
    """      - UnionShape
      |      - TupleShape
      |      - NodeShape
      |      - ArrayShape
      |      - SchemaShape
      |      - FileShape
      |      - MatrixShape
      |      - NilShape
      |      - ScalarShape
      |      - AnyShape
      |      - RecursiveShape
    """.stripMargin

  val settingsUnionDeclaration = "SecuritySettingsUnion"

  val settingsTypeDiscriminator =
    """    typeDiscriminatorName: type
      |    typeDiscriminator:
      |      OAuth2: OAuth2Settings
      |      OAuth1: OAuth1Settings
      |      APIKey: APIKeySettings
      |      Http: HTTPSettings
      |      OpenID: OpenIDSettings
    """.stripMargin

  val settingsUnionRange =
    """      - OAuth2Settings
      |      - OAuth1Settings
      |      - APIKeySettings
      |      - HTTPSettings
      |      - OpenIDSettings
    """.stripMargin

  val abstractDeclarationsRange =
    """          - ResourceType
      |          - Trait
    """.stripMargin

  val declarations =
    s"""    declares:
       |      dataShapes: $shapeUnionDeclaration
       |      resourceTypes: ResourceType
       |      traits: Trait
  """.stripMargin

  val endPointExtends =
    """      extends:
      |        propertyTerm: doc.extends
      |        typeDiscriminatorName: type
      |        typeDiscriminator:
      |          AppliedResourceType: ParametrizedResourceType
      |          AppliedTrait: ParametrizedTrait
      |        range:
      |          - ParametrizedResourceType
      |          - ParametrizedTrait
      |        allowMultiple: true
    """.stripMargin

  val operationExtends =
    """      extends:
      |        propertyTerm: doc.extends
      |        typeDiscriminatorName: type
      |        typeDiscriminator:
      |          AppliedTrait: ParametrizedTrait
      |        range:
      |          - ParametrizedTrait
      |        allowMultiple: true
    """.stripMargin

  val shapeNodeExtension    = "    extends: Shape\n"
  val anyShapeNodeExtension = "    extends: AnyShape\n"

  // We check if this node mapping is a shape that inherits from AnyShape (and inddirectly frmo Shape), so we can remove common properties
  // We also set up the node extension correctly to point to the AnyShape node mapping
  def checkAnyShapeBaseClass(dialectNodeMapping: DialectNodeMapping, stringBuilder: mutable.StringBuilder): Boolean = {
    if (dialectNodeMapping.isShape &&
        dialectNodeMapping.classTerm != (Namespace.Shacl + "Shape").iri() &&
        // dialectNodeMapping.classTerm != (Namespace.Shacl + "NodeShape").iri() && -> Our NodeShape *DOES* extends AnyShape
        dialectNodeMapping.classTerm != (Namespace.Shacl + "PropertyShape").iri() &&
        dialectNodeMapping.classTerm != (Namespace.Shapes + "AnyShape").iri()) {
      stringBuilder.append(anyShapeNodeExtension)
      true
    } else {
      false
    }
  }

  // We check if this node mapping is a shape that inherits from Shape and not from AnyShape, so we can remove common properties
  // We also set up the node extension correctly to point to the Shape node mapping
  def checkShapeBaseClass(dialectNodeMapping: DialectNodeMapping, stringBuilder: mutable.StringBuilder): Boolean = {
    if (dialectNodeMapping.isShape && (
          dialectNodeMapping.classTerm == (Namespace.Shapes + "AnyShape").iri() ||
          dialectNodeMapping.classTerm == (Namespace.Shacl + "PropertyShape").iri()
        )) {
      stringBuilder.append(shapeNodeExtension)
      true
    } else {
      false
    }
  }

  def renderDialect(): String = {
    val stringBuilder                              = new StringBuilder()
    val externals: mutable.HashMap[String, String] = mutable.HashMap()
    val header = "#%Dialect 1.0\n\n" ++
      "dialect: WebAPI\n" ++
      "version: 1.0\n\n"

    // Shapes union
    stringBuilder.append(s"  $shapeUnionDeclaration:\n")
    stringBuilder.append(shapeTypeDiscriminator + "\n")
    stringBuilder.append("    union:\n")
    stringBuilder.append(shapeUnionRange + "\n")

    // Security settings union
    stringBuilder.append(s"  $settingsUnionDeclaration:\n")
    stringBuilder.append(settingsTypeDiscriminator + "\n")
    stringBuilder.append("    union:\n")
    stringBuilder.append(settingsUnionRange + "\n")

    nodeMappings.foreach {
      case (_, dialectNodeMapping: DialectNodeMapping) =>
        if (!blacklistedMappings.contains(dialectNodeMapping.name)) {
          stringBuilder.append(s"  ${dialectNodeMapping.name}:\n")
          var (compacted, prefix, base) = compact(dialectNodeMapping.classTerm)
          aggregateExternals(externals, prefix, base)
          stringBuilder.append(s"    classTerm: $compacted\n")

          // Check inheritance for shapes
          var isBaseAnyShape = checkAnyShapeBaseClass(dialectNodeMapping, stringBuilder)
          val isBaseShape    = checkShapeBaseClass(dialectNodeMapping, stringBuilder)

          // Lets find the effecti property mappings for this node mapping
          val nodeMappingWithProperties = dialectNodeMapping.propertyMappings.filter { propertyMapping =>
            // dynamic and linking information only relevant for design will not be dumped in the dialect
            !blacklistedProperties.contains(propertyMapping.propertyTerm) &&
            !blacklistedRanges.contains(propertyMapping.range) &&
            allowedShapePropertyMapping(propertyMapping.propertyTerm, isBaseShape) &&
            allowedAnyShapePropertyMapping(propertyMapping.propertyTerm, isBaseAnyShape)
          }

          if (nodeMappingWithProperties.nonEmpty) {

            var propertyCounters: mutable.Map[String, Int] = mutable.Map() // for properties with dupplicated labels

            stringBuilder.append(s"    mapping:\n")

            if (dialectNodeMapping.classTerm == (Namespace.ApiContract + "EndPoint").iri()) {
              stringBuilder.append(endPointExtends + "\n")
            } else if (dialectNodeMapping.classTerm == (Namespace.ApiContract + "Operation").iri()) {
              stringBuilder.append(operationExtends + "\n")
            }

            nodeMappingWithProperties.map { propertyMapping =>
              // property names can be duplicated in the WebAPI meta-model, we make sure
              // we generate unique property mapping alias
              val name = propertyMapping.name
              val nextPropertyName = propertyCounters.get(name) match {
                case None =>
                  propertyCounters.update(name, 1)
                  name
                case Some(counter) =>
                  propertyCounters.update(name, counter + 1)
                  s"$name$counter"
              }
              // render the property mapping here
              stringBuilder.append(s"      $nextPropertyName:\n")
              var (compacted, prefix, base) = compact(propertyMapping.propertyTerm)
              aggregateExternals(externals, prefix, base)
              stringBuilder.append(s"        propertyTerm: $compacted\n")
              if (propertyMapping.range == "Shape") {
                stringBuilder.append(s"        range: $shapeUnionDeclaration\n")
              } else if (propertyMapping.range == "Settings") {
                stringBuilder.append(s"        range: $settingsUnionDeclaration\n")
              } else if (propertyMapping.range == "AbstractDeclaration") {
                stringBuilder.append(s"        range:\n")
                stringBuilder.append(abstractDeclarationsRange ++ "\n")
              } else if (propertyMapping.range == "uri") {
                stringBuilder.append(s"        range: link\n")
              } else {
                stringBuilder.append(s"        range: ${propertyMapping.range}\n")
              }
              if (propertyMapping.allowMultiple) {
                stringBuilder.append(s"        allowMultiple: ${propertyMapping.allowMultiple}\n")
              }

            }
          }
          stringBuilder.append("\n\n")
        }
    }

    stringBuilder.append("\n\n")
    stringBuilder.append("documents:\n")
    stringBuilder.append("  root:\n")
    stringBuilder.append(s"    encodes: ${toCamelCase(WebApiModel.doc.displayName)}\n")
    // TODO: union of declarations
    stringBuilder.append(declarations)

    val effectiveExternals = externals.filter {
      case (p, b) =>
        !WELL_KNOWN_VOCABULARIES.contains(b)
    }
    val effectiveVocabularies = externals.filter {
      case (p, b) =>
        WELL_KNOWN_VOCABULARIES.contains(b)
    } map {
      case (p, b) =>
        p -> WELL_KNOWN_VOCABULARIES(b)
    }

    val vocabularyDepedencies = "uses:\n" ++ effectiveVocabularies.map { case (p, b)  => s"  $p: $b\n" }.mkString ++ "\n"
    val externalDependencies  = "external:\n" ++ effectiveExternals.map { case (p, b) => s"  $p: $b\n" }.mkString ++ "\n"

    header ++ vocabularyDepedencies ++ externalDependencies ++ "nodeMappings:\n\n" ++ stringBuilder.mkString
  }

  def aggregateExternals(externals: mutable.HashMap[String, String], prefix: String, base: String): Unit = {
    if (!externals.contains(prefix)) {
      externals.update(prefix, base)
    }
  }

  def compact(url: String): (String, String, String) = {
    val compacted = Namespace.compact(url).replace(":", ".")
    val prefix    = compacted.split("\\.").head
    val base      = Namespace.ns(prefix).base
    (compacted, prefix, base)
  }

  def main(args: Array[String]): Unit = {

    val f      = new File(s"vocabularies/dialects/${DIALECT_FILE}")
    val writer = new FileWriter(f)
    try {
      println("*** Processing classes")
      VocabularyExporter.metaObjects(reflectionsWebApi, parseMetaObject)
      VocabularyExporter.metaObjects(reflectionsShapes, parseMetaObject)
      VocabularyExporter.metaObjects(reflectionsCore, parseMetaObject)
      VocabularyExporter.metaObjects(reflectionsTemplates, parseMetaObject)
      VocabularyExporter.metaObjects(reflectionsDataNode, parseMetaObject)
      val dialectText = renderDialect()
      println(dialectText)
      writer.write(dialectText)
    } finally {
      writer.close()
    }
  }
}
