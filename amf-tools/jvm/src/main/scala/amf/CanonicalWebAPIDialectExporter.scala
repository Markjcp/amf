package amf
import amf.core.metamodel.Type.Scalar
import amf.core.metamodel.{Field, Obj, Type}
import amf.core.vocabulary.Namespace
import amf.plugins.domain.webapi.metamodel.WebApiModel
import org.reflections.Reflections
import org.reflections.scanners.SubTypesScanner

import scala.collection.mutable

// Case classes to accumulate results
case class DialectNodeMapping(name: String, classTerm: String, propertyMappings: List[DialectPropertyMapping])
case class DialectPropertyMapping(name: String, propertyTerm: String, range: String, allowMultiple: Boolean)

/**
  * Logic that generates a 'canonical' dialect matching the structure in the meta-model for WebAPIs.
  * The goal of this dialect is to match the JSON-LD graph generated after parsing a RAML/OAS file with AMF.
  * This is different from the 'lexical' dialect for editing graph used by LS and generated by the DialectExporter object.
  */
object CanonicalWebAPIDialectExporter {

  val reflectionsWebApi     = new Reflections("amf.plugins.domain.webapi.metamodel", new SubTypesScanner(false))
  val reflectionsShapes     = new Reflections("amf.plugins.domain.shapes.metamodel", new SubTypesScanner(false))

  var nodeMappings: Map[String, DialectNodeMapping] = Map()

  def toCamelCase(str: String): String = {
    // str.replace(" ", "")
    val words = str.split("\\s+")
    if (words.size == 1) {
      words.head
    } else {
      (Seq(words.head) ++ words.tail.map(_.capitalize)).mkString
    }
  }

  def metaTypeToDialectRange(metaType: Type): (String, Boolean) = {
    metaType match {
      // objects
      case metaModel:Obj                               => (toCamelCase(metaModel.doc.displayName), false)
      // scalars
      case scalar: Scalar if scalar == Type.Str        => ("string", false)
      case scalar: Scalar if scalar == Type.RegExp     => ("string", false)
      case scalar: Scalar if scalar == Type.Int        => ("integer", false)
      case scalar: Scalar if scalar == Type.Float      => ("float", false)
      case scalar: Scalar if scalar == Type.Double     => ("double", false)
      case scalar: Scalar if scalar == Type.Time       => ("time", false)
      case scalar: Scalar if scalar == Type.Date       => ("date", false)
      case scalar: Scalar if scalar == Type.DateTime   => ("dateTime", false)
      case scalar: Scalar if scalar == Type.Iri        => ("uri", false)
      case scalar: Scalar if scalar == Type.EncodedIri => ("uri", false)
      case scalar: Scalar if scalar == Type.Bool       => ("boolean", false)
      // collections
      case Type.Array(t)                               => (metaTypeToDialectRange(t)._1, true)
      case Type.SortedArray(t)                         => (metaTypeToDialectRange(t)._1, true)
    }
  }

  def buildPropertyMapping(field: Field): DialectPropertyMapping = {
    val propertyTerm          = field.value.iri()
    val name = toCamelCase(field.doc.displayName)
    val (range, allowMultiple) = metaTypeToDialectRange(field.`type`)

    DialectPropertyMapping(name, propertyTerm, range, allowMultiple)
  }

  def buildNodeMapping(klassName: String, modelObject: Obj): DialectNodeMapping = {
    val doc         = modelObject.doc
    val types       = modelObject.`type`.map(_.iri())
    val id          = types.head
    val displayName = doc.displayName
    val description = doc.description
    val vocab       = doc.vocabulary.filename


    // index fields
    val propertyTerms = modelObject.fields.map(buildPropertyMapping)

    val nodeMapping = DialectNodeMapping(name = toCamelCase(displayName), classTerm = id, propertyMappings = propertyTerms)

    nodeMapping
  }

  def parseMetaObject(klassName: String): Option[DialectNodeMapping] = {
    nodeMappings.get(klassName) match {
      case cached @ Some(_) => cached
      case _                =>
        try {
          val singleton = Class.forName(klassName)
          singleton.getField("MODULE$").get(singleton) match {
            case modelObject: Obj =>
              val nodeMapping = buildNodeMapping(klassName, modelObject)
              nodeMappings += (klassName -> nodeMapping)
              Some(nodeMapping)
            case other =>
              //println(s"Other thing: $other")
              None
          }
        } catch {
          case _: ClassNotFoundException =>
            //println(s"NOT FOUND '${singletonKlassName}'")
            None
          case _: NoSuchFieldException =>
            //println(s"NOT FIELD '${singletonKlassName}'")
            None
        }
    }
  }

  val blacklistedProperties: Set[String] = Set(
    (Namespace.Document + "extends").iri(),
    (Namespace.Document + "link-target").iri(),
    (Namespace.Document + "link-label").iri(),
    (Namespace.Document + "recursive").iri()
  )

  val blacklistedRanges: Set[String] = Set(
    "DataNode"
  )

  val shapeUnionRange =
    """          - UnionShape
      |          - TupleShape
      |          - NodeShape
      |          - ArrayShape
      |          - SchemaShape
      |          - FileShape
      |          - MatrixShape
      |          - NilShape
      |          - ScalarShape
      |          - AnyShape
    """.stripMargin

  val settingsUnionRange =
    """          - OAuth2Setings
      |          - OAuth1Setings
      |          - APIKeySetings
      |          - HTTPSetings
      |          - OpenIDSetings
      |          
    """.stripMargin

  def renderDialect(): Unit = {
    val stringBuilder = new StringBuilder()
    val externals: mutable.HashMap[String,String] = mutable.HashMap()
    val header = "#%Dialect 1.0\n\n" ++
                 "dialect: WebAPI\n" ++
                 "version: 1.0\n\n"

    nodeMappings.foreach { case (_, dialectNodeMapping: DialectNodeMapping) =>
      stringBuilder.append(s"  ${dialectNodeMapping.name}:\n")
      var (compacted, prefix, base) = compact(dialectNodeMapping.classTerm)
      aggregateExternals(externals, prefix, base)
      stringBuilder.append(s"    classTerm: ${compacted}\n")
      stringBuilder.append("    mapping:\n")

      var propertyCounters: mutable.Map[String,Int] = mutable.Map()
      dialectNodeMapping.propertyMappings.foreach { propertyMapping =>
        // dynamic and linking information only relevant for design will not be dumped in the dialect
        if (!blacklistedProperties.contains(propertyMapping.propertyTerm) && !blacklistedRanges.contains(propertyMapping.range)) {
          // property names can be duplicated in the WebAPI meta-model, we make sure
          // we generate unique property mapping alias
          val name = propertyMapping.name
          val nextPropertyName = propertyCounters.get(name) match {
            case None =>
              propertyCounters.update(name, 1)
              name
            case Some(counter) =>
              propertyCounters.update(name, counter + 1)
              s"$name$counter"
          }
          // render the property mapping here
          stringBuilder.append(s"      ${nextPropertyName}:\n")
          var (compacted, prefix, base) = compact(propertyMapping.propertyTerm)
          aggregateExternals(externals, prefix, base)
          stringBuilder.append(s"        propertyTerm: ${compacted}\n")
          if (propertyMapping.range == "Shape") {
            stringBuilder.append(s"        range:\n")
            stringBuilder.append(shapeUnionRange ++ "\n")
          } else {
            stringBuilder.append(s"        range: ${propertyMapping.range}\n")
          }
          if (propertyMapping.allowMultiple) {
            stringBuilder.append(s"        allowMultiple: ${propertyMapping.allowMultiple}\n")
          }
        }
      }
      stringBuilder.append("\n\n")
    }
    stringBuilder.append("\n\n")
    stringBuilder.append("documents:\n")
    stringBuilder.append("  root:\n")
    stringBuilder.append(s"    encodes: ${toCamelCase(WebApiModel.doc.displayName)}\n")

    val dependencies = "external:\n" ++ externals.map { case (p, b) => s"  $p: $b\n" }.mkString ++ "\n"

    println(header ++ dependencies ++ "nodeMappings:\n\n" ++ stringBuilder.mkString)
  }

  def aggregateExternals(externals: mutable.HashMap[String, String], prefix: String, base: String) = {
    if (!externals.contains(prefix)) {
      externals.update(prefix, base)
    }
  }

  def compact(url: String): (String, String, String) = {
    val compacted = Namespace.compact(url).replace(":", ".")
    val prefix = compacted.split("\\.").head
    val base = Namespace.ns(prefix).base
    (compacted, prefix, base)
  }

  def main(args: Array[String]): Unit = {
    println("*** Processing classes")
    VocabularyExporter.metaObjects(reflectionsWebApi, parseMetaObject)
    VocabularyExporter.metaObjects(reflectionsShapes, parseMetaObject)
    renderDialect()
  }
}
